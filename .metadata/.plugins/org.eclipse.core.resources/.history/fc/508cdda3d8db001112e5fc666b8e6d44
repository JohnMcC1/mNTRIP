package com.mntripclient;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.widget.ArrayAdapter;

public class mNTRIPBluetoothTask implements Runnable {

	private BluetoothAdapter mBluetoothAdapter;
	private final ExecutorService bluetoothExecutorService;
	private ArrayAdapter<String> mArrayAdapter;
	private Activity activity;
	public final static int REQUEST_ENABLE_BT = 1;
	private static final UUID MY_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");

	public mNTRIPBluetoothTask(ExecutorService bluetoothExecutorService, Activity activity) {
		this.bluetoothExecutorService = bluetoothExecutorService;
		this.activity = activity;

		mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

		if (!mBluetoothAdapter.isEnabled()) {
			Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
			this.activity.startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
		} else {
			connect();
		}
	}

	private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
		public void onReceive(Context context, Intent intent) {
			String action = intent.getAction();

			if (BluetoothDevice.ACTION_FOUND.equals(action)) {

				BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);

				Log.e("DUPA", device.getName() + " " + device.getAddress());

				mArrayAdapter.add(device.getName() + "\n" + device.getAddress());
			}
		}
	};

	public void run() {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		@SuppressWarnings("unused")
		Future<?> future = bluetoothExecutorService.submit(this);
	}

	public void connect() {
//		IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
//		activity.registerReceiver(mReceiver, filter); // Don't forget to
//														// unregister during
//														// onDestroy

		// mBluetoothAdapter.startDiscovery();

		ConnectThread t = new ConnectThread(mBluetoothAdapter.getRemoteDevice("00:12:6F:27:04:CE"));
		t.start();

	}

	private class ConnectThread extends Thread {
		private final BluetoothSocket mmSocket;
		private final BluetoothDevice mmDevice;

		public ConnectThread(BluetoothDevice device) {
			// Use a temporary object that is later assigned to mmSocket,
			// because mmSocket is final
			BluetoothSocket tmp = null;
			mmDevice = device;

			// Get a BluetoothSocket to connect with the given BluetoothDevice
			try {
				Method m = device.getClass().getMethod("createRfcommSocket", new Class[] {int.class});
		        tmp = (BluetoothSocket) m.invoke(device, 1);
			} catch (IllegalArgumentException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (SecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchMethodException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
//			try {
//				tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
//			} catch (IOException e) {
//				e.printStackTrace();
//			}
			
			mmSocket = tmp;
		}

		public void run() {
			// Cancel discovery because it will slow down the connection
			//mBluetoothAdapter.cancelDiscovery();

			try {
				// Connect the device through the socket. This will block
				// until it succeeds or throws an exception
				mmSocket.connect();
			} catch (IOException connectException) {
				// Unable to connect; close the socket and get out
				Log.e("DUPA",  connectException.getMessage());
				try {
					mmSocket.close();
				} catch (IOException closeException) {
				}
				return;
			}

			// Do work to manage the connection (in a separate thread)
			manageConnectedSocket(mmSocket);
		}

		private void manageConnectedSocket(BluetoothSocket mmSocket2) {
			try {
				byte[] buffer = {'1', '2', '3', '4', '5', '1', '2', '3', '4', '5'};
				mmSocket2.getOutputStream().write(buffer, 0, 10);
				
			} catch (IOException e) {
				e.printStackTrace();
				Log.e("DUPA", e.getMessage());
			}
			
		}

		/** Will cancel an in-progress connection, and close the socket */
		public void cancel() {
			try {
				mmSocket.close();
			} catch (IOException e) {
			}
		}
	}

}
